<!doctype html><html lang="en"><head><title>Noel Varanda | Client-side Composition</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Love anything front end, ranging user animations to asset bundling. Talk to me."><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="manifest" href="/img/site.webmanifest"><link rel="mask-icon" href="/img/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><meta property="og:title" content="Client-side Composition"><meta name="twitter:title" content="Client-side Composition"><meta property="og:description" content="Love anything front end, ranging user animations to asset bundling. Talk to me."><meta property="twitter:description" content="Love anything front end, ranging user animations to asset bundling. Talk to me."><meta property="og:image" content="https://noelvaranda.dev/img/headshot.jpg"><meta name="twitter:image" content="https://noelvaranda.dev/img/headshot.jpg"><meta name="twitter:card" content="summary_large_image"><meta property="og:url" content="/notes/202102042232/"><style>:root{--background:#fff;--background-meta:#f3f3f3;--text-primary:#111111;--text-secondary:#494949;--text-tertiary:#717171;--link:#29769c;--link-hover:#1d5069;--link-focus-bg:#fd0;--highlight-bg:#69d8bc;--red:#C5004A;--font-size-s:1.2rem;--font-size-m:1.5rem;--font-size-l:1.8rem;--font-size-xl:3rem}a[href]{color:var(--link);-webkit-tap-highlight-color:rgba(0,0,0,.3)}a[href]:focus:not(:focus-visible),button:focus:not(:focus-visible){outline:2px solid transparent}a[href]:focus{outline:2px solid orange}a[href]:hover{color:var(--link-hover)}a[href]:active{color:var(--text-primary)}a[href]:visited{text-decoration:underline}.highlight-line{display:block;padding:.125em 1em;text-decoration:none;color:inherit}.highlight-line:empty:before{content:" "}.highlight-line+br{display:none}.highlight-line-isdir{color:#b0b0b0;background-color:#222}.highlight-line-active{background-color:#444;background-color:hsla(0,0%,27%,.8)}.highlight-line-add{background-color:#45844b}.highlight-line-remove{background-color:#902f2f}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:0 0;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.highlight-line{display:inline-block;text-decoration:none;color:inherit}.highlight-line:empty:before{content:" "}.highlight-line:not(:last-child){min-width:100%}.highlight-line .highlight-line:not(:last-child){min-width:0}.highlight-line-isdir{color:#b0b0b0;background-color:#222}.highlight-line-active{background-color:#444;background-color:hsla(0,0%,27%,.8)}.highlight-line-add{background-color:#45844b}.highlight-line-remove{background-color:#902f2f}.direct-link{font-family:sans-serif;text-decoration:none;font-style:normal;margin-left:.1em}a[href].direct-link,a[href].direct-link:visited{color:transparent}:hover>a[href].direct-link,:hover>a[href].direct-link:visited,a[href].direct-link:focus,a[href].direct-link:focus:visited{color:#aaa}.posts{list-style:none;padding:0;margin-top:40px}.posts__entry{position:relative;display:flex;padding:0 0 25px;line-height:2.4rem;flex-direction:column}@media screen and (min-width:40em){.posts__entry{padding:0 0 5px;flex-direction:row}}.posts__entry-date{width:120px;flex-shrink:0;display:inline-block;color:var(--text-tertiary)}table{margin:1em 0}table td,table th{padding-right:1em}.tag{display:inline-block;text-transform:uppercase;font-size:var(--font-size-s);padding:0 4px;margin-left:.8em;background-color:var(--red);color:var(--background);border-radius:.25em;text-decoration:none}a[href].tag,a[href].tag:visited{color:var(--background)}:root{--lightgray:#e0e0e0;--navy:#17050F;--blue:#082840;--app-width:650px}@media screen and (min-width:70em){:root{--app-width:715px}}*{box-sizing:border-box}body,html{padding:0;margin:0;font-family:HelveticaNeue-Light,"Helvetica Neue Light","Helvetica Neue",Helvetica,Arial,"Lucida Grande",sans-serif}html{font-size:62.5%}body{background-color:var(--background-primary);color:var(--text-secondary);line-height:2.1rem;font-size:var(--font-size-l);font-weight:400}::selection{background:var(--highlight-bg)}li,p{font-size:var(--font-size-l);line-height:3rem}p:last-child{margin-bottom:0}.app{display:flex;min-height:100vh;margin:0 auto}.app__gutter{display:none;position:relative;flex:0 0 auto;overflow:hidden}.app__gutter,.app__interactive{transition:flex 280ms ease-out}.app__interactive{display:flex;position:absolute;top:0;left:0;bottom:0;width:calc(1980px - var(--app-width) - 64px);transform:translateX(calc(-1 * (1980px - var(--app-width) - 64px)));transition:transform 280ms ease-out,background-color 280ms ease-out,box-shadow 280ms ease-out}.app__trigger{display:none;align-items:center;justify-content:center;height:100vh;box-sizing:border-box;background-color:#fff;width:64px;box-shadow:2px 0 2px rgba(0,0,0,.04);outline:0;border:none;cursor:pointer;z-index:2}.app__trigger:hover{box-shadow:4px 0 4px rgba(0,0,0,.04)}.app__trigger:hover path{stroke:var(--link)}.app__trigger:focus:not(:focus-visible) svg{outline:2px solid transparent}.app__trigger:focus svg{outline:3px solid orange;outline-offset:3px}.app__interactive-network{width:100%;height:100%;border:none;margin:0;padding:0;z-index:1;position:absolute;right:0;top:0;transition:transform 280ms ease-out,opacity 280ms ease-out}.app__interactive-network .vis-network:focus{outline:0}.app__main{display:flex;flex-direction:column;height:100vh;width:100%;padding:0 10px 30px;min-width:300px;box-sizing:border-box;flex:0 1 var(--app-width);transition:flex 280ms ease-out;background-color:#fff;margin:0 auto}@media screen and (min-width:70em){.app__gutter,.app__trigger{display:flex}.app_main{padding:0 30px 30px}}@media print{.app__gutter,.app__trigger{display:none}}@media screen and (min-width:40em){.app__main{padding:0 40px 50px}}.page-content{padding-bottom:80px}.content{margin:auto;padding:40px 20px;width:100%}@media screen and (min-width:40em){.blog-post{padding:40px 20px 140px}}.content__back{display:inline-block;margin:0 0 60px;height:20px}@media print{.content__back{display:none}}#page-back{visibility:hidden}.app--open .app__gutter{flex:1 1 auto}.app--open .app__interactive{transform:translateX(0);background-color:#f7f7f7;box-shadow:inset 30px -2px 74px -30px rgb(0 0 0 / 10%)}.app--open #page-back{visibility:visible}.app--open .app__interactive-network{display:block}h1{color:var(--text-primary);line-height:4rem;margin:20px 0 10px}h2{margin:20px 0 10px}img{max-width:100%}.paragraph--last{margin-bottom:50px}blockquote{font-style:italic;color:grey;margin:50px 0;position:relative}blockquote::before{content:'';position:absolute;border-left:4px solid #c2c2c2;height:100%;left:-20px;border-top-left-radius:4px;border-bottom-left-radius:4px}.time{margin-bottom:60px;display:block}@keyframes slidein{from{opacity:0;top:10%}to{opacity:1;top:0}}@media screen and (min-width:70em){.app--interactive{overflow:hidden;max-width:1980px}.app--interactive .app__main{overflow-y:auto;overflow-x:hidden;margin:0}}</style></head><body><main class="app app--interactive app--open"><div class="app__gutter" id="gutter" role="region" aria-labelledby="notes-trigger"><div class="app__interactive"><div id="network" class="app__interactive-network"></div></div></div><button class="app__trigger" id="notes-trigger" aria-label="Toggle notes archive" aria-expanded="true" aria-controls="gutter" data-open="true"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 8L3 12L7 16" stroke="#333333" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M17 16L21 12L17 8" stroke="#333333" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class="app__main" id="app-main"><section class="content"><a href="/" class="content__back" id="page-back">Return back home</a><h1 id="page-title">Client-side Composition</h1><div class="page-content"><p class="paragraph">Client-side composition is the idea of assembling markup from a number of different micro-frontends on the user's device. Client-side rendered applications permit building rich and reactive user interfaces, so assembling micro frontends on the client leverages this benefit.</p><p class="paragraph">Though client-side composition allows us to have an app-like feel, user experience is limited due to the asynchronous loading of fragments, causing a jumping UI. It also incurs an expensive load time due to JavaScript loading and running being dependent on a user's device.</p><p class="paragraph">Communication between micro frontends is a major factor to consider when opting for client-side composition as when one micro frontend changes the others may need up react to this change too.</p><p class="paragraph">A few ways that client-side composition can be achieved include:</p><h4 id="usingiframes">Using iframes</h4><p class="paragraph">In its simplest form, composing different micro frontend fragments can be done using iframes to load in applications from different resources.</p><p class="paragraph">Though iframes are a quick solution, the poor markup produced by iframes leads to issues with accessibility and SEO. Layout constraints also exist due outer layers needing to know the iframe's exact height to avoid scrollbars. Lastly there is a large performance overhead due to eac h iframe running in its own nested browsing context. #potential-fleet</p><h4 id="usingajax">Using Ajax</h4><p class="paragraph">Ajax directly on the client code can be used to inject different micro-frontends into an application.</p><p class="paragraph">Using Ajax has its benefits over using, for instance, iframes as it has a natural document flow, meaning its height does not need to be set by the outer container, and the markup is valid meaning better accessibility and SEO. Dealing with errors and failing fragments is also made easier (e.g. showing errors or adding placeholders) as the fragment is part of the outer layer's markup.</p><p class="paragraph">However it causes difficulties in scoping, forcing us to require namespacing in CSS, cookies, events, and other browser globals. Furthermore any time something happens on one micro frontend, a server request is required to re-fetch the updated markup of the other micro frontends. Lastly knowing when scripts should be terminated is difficult causing memory management to be difficult.</p><blockquote><p class="paragraph"><a href="https://github.com/gustafnk/h-include">h-include</a> is a library which helps facilitate some of the setup and pain points caused by Ajax. #fe-library</p></blockquote><h4 id="usingwebcomponents">Using Web components</h4><p class="paragraph">Custom elements offer the major advantage of business logic encapsulation, and come equipped with lifecycle methods which can be used to determine whether they have been created, updated, or destroyed. As such they can be leveraged as a technology-neutral interface when implementing a micro frontend. The Shadow DOM can be leveraged to ensure styles do not leak across different parts of an application - avoiding the need for policing of namespaces.</p></div></section></div><script type="module">import { createApp } from '/assets/bundle.22022021.js';

        createApp({"selectedNode":202102042232,"notes":{"nodes":[{"bodyHtml":"<p class=\"paragraph\" >Micro frontends are an architectural approach to building user interfaces where applications are split into vertical slices (small domain-driven sections of an application); removing the need for a centralised front end team, and instead favouring small cross functional teams.</p>\n<p class=\"paragraph\" >Multiple codebases mean fewer lines of code per application; reducing the impact of tightly coupled code and bugs. This making it easier for teams to ship code without needing to coordinate with other teams. Smaller codebases also cater for rapidly changing tech due to a smaller blast radius when upgrading dependencies - updating the framework on a monolithic app, for instance, would be far more challenging. Lastly the lack of large teams means small architectural decisions can be made on the fly instead of in large meetings.</p>\n<p class=\"paragraph\" >Micro frontends are not a technical concept, they are an organisational, and architectural approach. There are three essential concepts that glue different teams using micro frontends: <strong>design system</strong>, <strong>performance</strong>, and <strong>shared knowledge</strong>.</p>","id":202101301828,"metaData":{"tags":["literature-note","index-card"]},"linksTo":[202101301829,202102071208,null],"label":"Micro Frontends"},{"bodyHtml":"<p class=\"paragraph\" >Cross functional teams are interdisciplinary teams formed of members with a common goal. They include members from different departments of organisations, and aim to solve for slow communication lines caused by specialized teams.</p>\n<p class=\"paragraph\" >The main benefits are not only that features are faster to deliver due to the quick communication paths, but he user becomes the focus; as opposed to in specialised teams where the team's function is the focus. Adopting this strategy causes a small sacrifice for code quality, so adopting architectural patterns such as micro frontends can aid this.</p>","id":202101301829,"metaData":{"tags":["literature-note"]},"linksTo":[202101301828,null],"label":"Cross Functional Teams"},{"bodyHtml":"<p class=\"paragraph\" >Server-side composition is the idea of composing markup from a number of micro frontends on the server. This technique can be used to improve user experience by bringing faster load times for the user. </p>\n<p class=\"paragraph\" >Leveraging server-side composition means that requests made to different servers to fetch micro frontend fragments of markup aren't limited by the client's bandwidth, which in turn can mean better load times for users. More techniques such as parallel loading, and streaming responses can further boost these low loading times.</p>\n<p class=\"paragraph\" >On the flip side multiple resources being fetched on the server also mean more points of failure therefore when composing markup. In order to avoid entire pages slowing down, or failing to load due to a flaky fragment, timeouts are used to give fragments time limits to load, and fallbacks are used to populate the markup in case the fragment doesn't load at all.</p>\n<p class=\"paragraph\" >When deciding on a server side composition architecture, teams must chose between a centralised approach or a distributed approach, where composition is nested in micro-frontends (see more on Podium).</p>\n<p class=\"paragraph\" >A few ways that server-side composition can be achieved include:\n    - <a href=\"/notes/202102071141\" data-navigo>NGINX Server-side Includes</a>\n    - <a href=\"https://github.com/zalando/tailor\">Tailor</a> #fe-library\n    - <a href=\"https://podium-lib.io/\">Podium</a> #fe-library </p>","id":202102042224,"metaData":{"aliases":["server-side rendering"],"tags":["literature-note"]},"linksTo":[202102071141,202102042246,null],"label":"Server-side Composition"},{"bodyHtml":"<p class=\"paragraph\" >Client-side composition is the idea of assembling markup from a number of different micro-frontends on the user's device. Client-side rendered applications permit building rich and reactive user interfaces, so assembling micro frontends on the client leverages this benefit.</p>\n<p class=\"paragraph\" >Though client-side composition allows us to have an app-like feel, user experience is limited due to the asynchronous loading of fragments, causing a jumping UI. It also incurs an expensive load time due to JavaScript loading and running being dependent on a user's device.</p>\n<p class=\"paragraph\" >Communication between micro frontends is a major factor to consider when opting for client-side composition as when one micro frontend changes the others may need up react to this change too.</p>\n<p class=\"paragraph\" >A few ways that client-side composition can be achieved include:</p>\n<h4 id=\"usingiframes\">Using iframes</h4>\n<p class=\"paragraph\" >In its simplest form, composing different micro frontend fragments can be done using iframes to load in applications from different resources.</p>\n<p class=\"paragraph\" >Though iframes are a quick solution, the poor markup produced by iframes leads to issues with accessibility and SEO. Layout constraints also exist due outer layers needing to know the iframe's exact height to avoid scrollbars. Lastly there is a large performance overhead due to eac h iframe running in its own nested browsing context. #potential-fleet</p>\n<h4 id=\"usingajax\">Using Ajax</h4>\n<p class=\"paragraph\" >Ajax directly on the client code can be used to inject different micro-frontends into an application.</p>\n<p class=\"paragraph\" >Using Ajax has its benefits over using, for instance, iframes as it has a natural document flow, meaning its height does not need to be set by the outer container, and the markup is valid meaning better accessibility and SEO. Dealing with errors and failing fragments is also made easier (e.g. showing errors or adding placeholders) as the fragment is part of the outer layer's markup.</p>\n<p class=\"paragraph\" >However it causes difficulties in scoping, forcing us to require namespacing in CSS, cookies, events, and other browser globals. Furthermore any time something happens on one micro frontend, a server request is required to re-fetch the updated markup of the other micro frontends. Lastly knowing when scripts should be terminated is difficult causing memory management to be difficult.</p>\n<blockquote>\n  <p class=\"paragraph\" ><a href=\"https://github.com/gustafnk/h-include\">h-include</a> is a library which helps facilitate some of the setup and pain points caused by Ajax. #fe-library</p>\n</blockquote>\n<h4 id=\"usingwebcomponents\">Using Web components</h4>\n<p class=\"paragraph\" >Custom elements offer the major advantage of business logic encapsulation, and come equipped with lifecycle methods which can be used to determine whether they have been created, updated, or destroyed. As such they can be leveraged as a technology-neutral interface when implementing a micro frontend. The Shadow DOM can be leveraged to ensure styles do not leak across different parts of an application - avoiding the need for policing of namespaces.</p>","id":202102042232,"metaData":{"tags":["literature-note"]},"linksTo":[202102061841,202102071605,null],"label":"Client-side Composition"},{"bodyHtml":"<p class=\"paragraph\" >When composing markup on the server, a number of techniques can be used to mitigate for the effect of misbehaving fragments, which can cause performance or the user's experience to degrade.</p>\n<h3 id=\"loadingfragmentsinparallel\">Loading fragments in parallel</h3>\n<p class=\"paragraph\" >By loading all fragments in parallel, the loading time will only be as slow as time taken to load the slowest fragment, as opposed to a sum of all fragments.</p>\n<h3 id=\"avoidingnestedfragments\">Avoiding nested fragments</h3>\n<p class=\"paragraph\" >Nesting fragments can potentially increase response time as loading in parallel cannot be done for all fragments. Avoiding nested fragments can therefore mean faster response times.</p>\n<h3 id=\"deferringloadingtoclientside\">Deferring loading to client-side</h3>\n<p class=\"paragraph\" >This technique is used to deffer specific fragments to load on the client-side instead of the server. This means we leverage the server for essentials (E.g. what is in the user's viewport), and offload non-essentials to load after the user is able to see the page.</p>\n<h3 id=\"streamingresponses\">Streaming responses</h3>\n<p class=\"paragraph\" >This is the concept of sending parts of the response at a time, as they are resolved. Doing so means the first transfer to the browser is made as soon as the first part is resolved, making the Time-to-first-byte very fast for the user. </p>","id":202102042246,"metaData":{"tags":["literature-note","performance"]},"linksTo":[202102042224,null],"label":"Server Markup Assembly Performance"},{"bodyHtml":"<p class=\"paragraph\" >Clearly defined communication paths and boundaries are necessary to assure state is consistent and loosely coupled across micro frontends. Fragments need to be able to communicate to their parents, and each other, and global context needs to persist across all fragments. Rules surrounding events, boundaries, loading times, and state should be considered in communication. </p>\n<p class=\"paragraph\" >Events should be seen as notifications, and avoid being used to transfer data. The more data we transfer in an event, the more dependency we have on external events to make our micro frontend work. So simple nudges are best suited.</p>\n<p class=\"paragraph\" >Micro frontends are supposed to be well contained, so too much communication to other micro frontends could be indicative of poorly defined boundaries. It is therefore extremely important to define the boundaries of micro frontends before starting to build them.</p>\n<p class=\"paragraph\" >Asynchronous loading of fragments means not all fragments might have loaded when an event is sent. Standard events could therefore not suffice to update different micro frontends if one has not loaded in time. For example if micro frontend #1 updates, and micro frontend #2 needs to react to this change but has not yet loaded this could cause inconsistency.</p>\n<p class=\"paragraph\" >Lastly, as tempting as it may be to use stores and API calls that persist across micro frontends, it is important to keep these separate as sharing state and stores causes for tight coupling. For example if micro frontend #1 wanted to change the structure of their store but micro frontend #2 was also using this, then there would need to be unnecessary communication and accord to do so. A small duplication is sometimes better than the wrong abstraction. #potential-fleet</p>\n<h3 id=\"parenttochildchildtoparent\">Parent to child / child to parent</h3>\n<p class=\"paragraph\" >Parent to fragment communication can be done using the \"props down, events up\" technique, where a parent communicates to fragments via their attributes, and the vice-versa is done using native events.</p>\n<h3 id=\"siblingtosibling\">Sibling to Sibling</h3>\n<p class=\"paragraph\" >Communication between siblings is sometimes necessary when one part of the app needs to talk to the other but the logic does not make sense to reside in a parent.</p>\n<p class=\"paragraph\" >Direct communication (E.g. traversing a DOM tree) causes tight coupling, meaning if one of the siblings changes then the other will break too. Using an event-bus/broadcasting model allows siblings to publish and subscribe to actions without knowing about what other siblings may be using them, allowing fragments to communicate to each other without coupling. The <strong>Broadcast API</strong> is a native browser feature that allows this, and persists across pages/tabs.</p>\n<h3 id=\"globalcontext\">Global context</h3>\n<p class=\"paragraph\" >Managing global context such as <strong>authentication</strong> can be done leveraging proxies which inject context into HTTP response headers when information comes from server, or a global JavaScript API if the information is on the UI. An app shell is a common place to house this sort of information.</p>","id":202102061841,"metaData":{"tags":["literature-notes"]},"linksTo":[202102062302,null],"label":"Micro Frontend Communication Patterns"},{"bodyHtml":"<p class=\"paragraph\" >Routing navigation and transitions is one of the main considerations when integrating multiple micro frontends into a single application. It can be accomplished in simple but limiting ways by using links, or more complex but user-rich experiences by using app shells.</p>\n<h3 id=\"routingusinglinks\">Routing using links</h3>\n<p class=\"paragraph\" >At its simplest form routing between micro front ends can be implemented by hosting two different Web pages to serve different applications.</p>\n<h3 id=\"routingontheserver\">Routing on the server</h3>\n<p class=\"paragraph\" >A proxy layer, using for instance NGINX, can be used to unify URLs under one domain. This comes with various limitations such as micro frontends being restricted to pages, duplication of common sections (e.g. navbars), and hard navigation (pages fetched from server) between pages.</p>\n<h3 id=\"routingusinganappshell\">Routing using an app shell</h3>\n<p class=\"paragraph\" >The three aforementioned problems can be solved by using an app shell - a parent application for all micro frontends.</p>","id":202102062241,"metaData":{"aliases":["routing"],"tags":["literature-note"]},"linksTo":[202102071208,202102071240,null],"label":"Micro Frontend Routing"},{"bodyHtml":"<p class=\"paragraph\" >An app shell acts as a parent application for all micro frontends. It should not contain any business logic; instead the app shell has two main responsibilities: loading code from different micro frontends and client-side routing between pages.</p>\n<p class=\"paragraph\" >Other common features that appear in app shells include: </p>\n<ul>\n<li>Authentication.</li>\n<li>Tracking managers and analytics.</li>\n<li>Performance monitoring.</li>\n<li>Error reporting.</li>\n</ul>","id":202102062302,"metaData":{"tags":["reference-note"]},"linksTo":[202102071240,null],"label":"App Shells"},{"bodyHtml":"<p class=\"paragraph\" >Universal rendering combines both client- and server-side rendering to leverage the advantages giving the user the quick load times of server-side composition, and the interactive app-feel of client-side composition.</p>\n<p class=\"paragraph\" >Universal rendering requires micro frontends to be able to be rendered on both the server, and the client. This is difficult when using native elements such as iframes or Web components as these don't render on the server.</p>\n<p class=\"paragraph\" >TBCOMPLETED (page 153-155)</p>","id":202102071117,"metaData":{"aliases":["Server-side Rendering","Isomorphic Rendering"],"tags":["literature-note"]},"linksTo":[202102042224,202102042232,null],"label":"Universal Rendering"},{"bodyHtml":"<p class=\"paragraph\" ><a href=\"https://www.nginx.com/\">NGINX</a> is equipped with SSI (server side includes); placeholders put in code with a URL which when resolved by NGINX will be replaced with the markup outputted.</p>\n<p class=\"paragraph\" >When adopting SSI, timeouts and fallbacks are used to avoid entire pages failing slowing down, or failing to load due to a flaky fragment.</p>","id":202102071141,"metaData":{"aliases":["SSI"],"tags":["literature-note","fe-library"]},"linksTo":[202102042224,null],"label":"NGINX Server-side Includes"},{"bodyHtml":"<p class=\"paragraph\" >Micro frontends can be implemented a number of ways ranging linking pages to delivering unified universal SPAs. Different approaches often depend on what is required, and are defined by the approaches chosen to route and compose the application.</p>\n<p class=\"paragraph\" >There are six main architectural approaches that can be used (each higher in complexity than the one before):</p>\n<ol>\n<li><strong><a href=\"/notes/202102062241\" data-navigo>Micro Frontend Routing</a></strong></li>\n<li><strong><a href=\"/notes/202102062241\" data-navigo>Micro Frontend Routing</a></strong></li>\n<li><strong>Linked SPAs</strong> (Hard navigation between different SPAs).</li>\n<li><strong>Linked Universal SPAs</strong> (Hard navigation between different SPAs with universal rendering).</li>\n<li><strong><a href=\"/notes/202102071240\" data-navigo>Routing Using an App Shell</a></strong> (One SPA (app shell) composed of multiple SPAs).</li>\n<li><strong>Unified Universal SPA</strong> (One SPA (app shell) composed of multiple SPAs with universal rendering).</li>\n</ol>\n<h3 id=\"decidingwhichapproach\">Deciding which approach</h3>\n<p class=\"paragraph\" ><img loading=\"lazy\" src=\"https://freecontent.manning.com/wp-content/uploads/which-techniquearchitecture-is-right-for-my-project_04.png\" alt=\"\">\nTo help decide which is the best approach, we can use the Documents-to-Application Continuum to decide if we need server-side, client-side, or universal rendering.</p>\n<p class=\"paragraph\" >We can use this in combination with the following decision tree to help us decide: <img loading=\"lazy\" src=\"https://freecontent.manning.com/wp-content/uploads/which-techniquearchitecture-is-right-for-my-project_06.jpg\" alt=\"\"></p>","id":202102071208,"metaData":{"tags":["literature-note","architecture"]},"linksTo":[202102062241,202102062241,202102071240,202102062241,202102071605,202102071117,null],"label":"Micro Frontend Architecture"},{"bodyHtml":"<p class=\"paragraph\" >Leveraging an app shell can be a powerful tool to make navigating between micro frontends seemless</p>\n<h3 id=\"singlelevelrouting\">Single-level routing</h3>\n<p class=\"paragraph\" >In a single-level routing model, the app shell will load the code for each of the micro frontends, as well as host configuration for all of the routes of an application. The configuration can be something as simple as a key/value store mapping URLs to component names (this example uses custom elements):</p>\n<pre class=\"language-markup\" ><code class=\"ts language-ts\">const routes = {\n  '/checkout/payments': 'custom-element-from-first-micro-fe',\n  '/checkout/shipping': 'another-element-from-first-micro-fe',\n  '/survey/creator': 'ace-element-from-second-micro-fe',\n  '/survey/results': 'king-element-from-second-micro-fe'\n}\n</code></pre>\n<p class=\"paragraph\" >Routing logic is then inserted (using for example the native history API or a library) where page links are intercepted and using the configuration above the app shell will fetch the appropriate code (in this example; custom element) for the route.</p>\n<p class=\"paragraph\" >The main issue with this way of routing is the fact that anytime micro frontend needs to add routes, they need to add to the app shell. Any routing logic also needs to reside in the app shell, which when micro frontend-specific can mean that business logic is leaking into the supposedly feature-agnostic layer.</p>\n<h3 id=\"twolevelrouting\">Two-level routing</h3>\n<p class=\"paragraph\" >Two level routing divides routing into app shell-, and micro fronted-level routing. The app shell level router, or top level router, houses simple sections.</p>\n<pre class=\"language-markup\" ><code class=\"ts language-ts\">const routes = {\n  '/checkout': 'custom-element-first-micro-fe',\n  '/survey': ''custom-element-second-micro-fe'\n}\n</code></pre>\n<p class=\"paragraph\" >Once this is done, then different micro frontends can implement their section-level routes using the different technologies they desire (e.g. vue-router on <code>/checkout</code> and react-router on <code>/survey</code>).</p>\n<p class=\"paragraph\" >When using an app shell to route, it is always important to remember to cleanup any listeners once tfhe micro frontend has been disconnected in order to avoid memory leaks.</p>\n<h3 id=\"libraries\">Libraries</h3>\n<ul>\n<li><a href=\"https://single-spa.js.org/\">single-spa</a> acts as an app shell out of the box. Different micro frontends expose their code using a common interface, and register their base route on on the app shell. Single-spa also handles topics such as error handling or lazy loading. #fe-library </li>\n</ul>\n<h3 id=\"importanttopicstoconsider\">Important topics to consider</h3>\n<ul>\n<li>Shared HTML document and meta data.</li>\n<li>Memory management and clean up.</li>\n<li>App shell is a single point of failure, so heavy testing and good architecture are vital.</li>\n<li>Boot time of different micro frontends.</li>\n</ul>","id":202102071240,"metaData":{"aliases":["Stitching Layer"],"tags":["literature-note"]},"linksTo":[202102062241,202102062302],"label":"Routing Using an App Shell"},{"bodyHtml":"<p class=\"paragraph\" >In practice different micro frontends are bound to appear on the same page. An example is when showing a header bar next to page content, or nested fragments. Composition  techniques can be grouped into server- and client-side composition.</p>","id":202102071605,"metaData":{"tags":["literature-note"]},"linksTo":[202102042224,202102042232,null],"label":"Micro Frontend Composition"},{"bodyHtml":"<p class=\"paragraph\" >Loading asset bundles from multiple micro frontends can be a challenging task. Ensuring different micro frontends can deploy independently, deprecated cached assets are cache busted on user's machines, and asset synchronization during deployments are all accounted for, micro frontends need to version manifests alongside their code.</p>\n<h3 id=\"considerations\">Considerations</h3>\n<p class=\"paragraph\" >Two main considerations need to accounted for when loading assets; cache-busting to ensure the user always sees the latest version, and synchronization to assert that rolled deployments do not cause 404 errors.</p>\n<h4 id=\"cachebustingandindependentdeployments\">Cache-busting and independent deployments</h4>\n<p class=\"paragraph\" >Most browsers (and applications) are optimised to cache static assets (images, CSS files, JavaScript, etc.) on a user's machine. This is a verified way to increase performance, however causes difficulties providing files when continuous deployment is a business requirement. For example exposing a file called <code>fragment.css</code> will no longer suffice as it will be cached on a user's machine, and updates to <code>fragment.css</code> will not reflect on that user's machine. In order to assert that a file gets cached, a technique called \"cache busting\" is used where a fingerprint is added to the end of the URL (E.g. <code>fragment.72.js</code>). Each subsequent deployment will add a new fingerprint.</p>\n<h4 id=\"synchronization\">Synchronization</h4>\n<p class=\"paragraph\" >In order to deal with high amounts of traffic, applications usually run multiple instances, and a load balancer is then used to distribute requests evenly across these instances. As new versions of an application are deployed, their instances are replaced with new instances, one-by-one to assert most instances are running at once.</p>\n<p class=\"paragraph\" >The downside to replacing instances one-by-one is that whilst deploying new versions, the resources provided by each instance could differ. For example if a deployment is undergoing and one instance has been replaced, but the rest haven't, then one instance might serve <code>fragment.74.js</code>, whilst the others can serve <code>fragment.73.js</code>. A user could make a request to an application which has a dependency on <code>fragment.74.js</code> but when it makes the request to fetch this resource, the load balancer could redirect it to an instance only containing <code>fragment.73.js</code>, causing a 404 on this resource.</p>\n<h3 id=\"solvingforcachingandsynchronization\">Solving for caching and synchronization</h3>\n<p class=\"paragraph\" >In order to guarantee the user's resources are cache busted, and synchronization is accounted when deploying, each micro frontend can provide a <code>manifest.json</code>. This manifest should contain links to the static resources, as well as the version it is providing.</p>\n<pre class=\"language-markup\" ><code>{\n  version: 1,\n  css: 'my-css.123.css',\n  js: 'my-js.123.js',\n}\n</code></pre>\n<p class=\"paragraph\" >When the HTML content is fetched, a <code>version</code> is returned in the header, when we look at our cached <code>manifest.json</code>, we compare its version to the one returned in the HTML response. If they don't match then we request a new <code>manifest.json</code> and update it. </p>\n<blockquote>\n  <p class=\"paragraph\" ><a href=\"https://podium-lib.io/\">Podium</a> provides out-of-the-box functionality for creating versioned manifests. #fe-library</p>\n</blockquote>","id":202102072253,"metaData":{"tags":["reference-notes","caching","assets"]},"linksTo":[202101301828,202102121403,null],"label":"Micro Frontends Asset Loading"},{"bodyHtml":"<p class=\"paragraph\" >Bundle granularity referrers to how big or small static assets served to a user should be. Front end chapters can choose to serve assets by sections or fragments, or anywhere in between, but performance should be considered when doing so. </p>\n<p class=\"paragraph\" >Picking the right granularity is essential as it allows teams to understand how they will code-</p>\n<h4 id=\"ondemandloading\">On-demand loading</h4>\n<p class=\"paragraph\" >TBC</p>","id":202102121403,"metaData":{"tags":["reference-notes","performance","assets"]},"linksTo":[null],"label":"Asset Bundle Granularity"},{"bodyHtml":"<p class=\"paragraph\" >Everybody, consciously or not, loves performant applications, and as a consequence engineers spend a lot of time trying to assert visual stability, interactivity, fast loading times, amongst other aspects of performance when delivering features. There are a number of great resources out there telling us <em>why</em> performance is important, or <em>how</em> to make our applications performant, which I will link at the end of this post, but this post focuses on how we can improve performance without code.</p>\n<p class=\"paragraph\" >Application performance does not start in code, it starts when an idea is conceived, and its expectations are set. We have a lot of useful&nbsp;metrics, auditors, strategies, debuggers, and tools&nbsp;that help us build highly performant applications. But what does it mean for an application to be \"performant\"?</p>\n<p class=\"paragraph\" >A <em>behaviour-centric</em> page such as a dashboard with a lot of graphs may not need the most performant load time, but needs to be highly responsive. On the flip-side, a <em>content-centric</em> blog might not need every embedded video to be immediately interactive, but it needs page loads with the vital information to be shown speedily. Or if a user is told that a generated report will take up to 10 minutes to create - a relatively slow request time - it could be perceived as \"fast\" if it is done in 2 minutes.</p>\n<p class=\"paragraph\" >Automating or ensuring \"performant\" apps at a code level is difficult as the definition of \"performant\" might not mean the same for every UI slice of an application; the way we measure a slice's performance is completely relative to what that slice needs or does. What this in turn means though is that standard performance auditors might not always paint a full picture. For example, a high score on page load speed using <a href=\"https://developers.google.com/web/tools/lighthouse\">Lighthouse</a> can be insignificant if that isn't what the user needs to have an enjoyable experience.</p>\n<p class=\"paragraph\" >By slicing our application into small slices from a user's perspective, we are able to understand how performant different parts of an application should be, and allocating useful metrics becomes easier.  Deciding on how to slice an application is entirely on a company's needs/wants, and isn't to be confused with the way we slice <a href=\"https://martinfowler.com/bliki/BoundedContext.html\">bounded context in Domain-driven design</a>, or how we slice micro-frontends, but could be similar.</p>\n<p class=\"paragraph\" >Anytime we add functionality we can ask \"what performance does this slice of UI need to provide an acceptable user experience?\" and write these down somewhere company-visible. The solution to good performance could be a simple design, a fast API, or instant user response, it depends on what the user needs. The important part is that we are thinking and writing these up when the idea is conceived so that performance is centered around the&nbsp;<em>user</em>&nbsp;not the&nbsp;<em>function</em>. Performance is, and should be a cross-functional concern.</p>\n<p class=\"paragraph\" >As we write more and more&nbsp;expectations of performance, the boundaries around slices of our application start to become more clear and we start to be able to be able to accurately justify what it means for our application to be \"performant\".</p>\n<p class=\"paragraph\" >As a consequence of defining performance at a user level, it becomes easier to define and automate telemetry systems in code, or per service. We also now know what we should and shouldn't log, or should look out for in code reviews. So not only does centering performance at the idea inception stage help the <em>user</em>, we in turn make it easier to automate and assert it at a <em>function</em> level.</p>","id":202102121749,"metaData":{"tags":["permanent-note","performance","article"]},"linksTo":[202102241726],"label":"Improving App Performance Without Code"},{"bodyHtml":"<p class=\"paragraph\" >One of the benefits of working at Attest is its 10% time; as an employee you can optionally take 10% of your time to go off and better either yourself or the company. This is quite common amongst tech companies, and in fact Gmail and Maps were both invented in Google's 20% time. It's that short period of time where you're not bound to team responsibilities, or deadlines, and can focus solely on what you (or a team of you) think will improve the platform or yourselves. This short post goes into where I spent my 10% time; what I am proud of, what I regret, and what I would have done differently.</p>\n<p class=\"paragraph\" >I used to have regular meetings with the COO of Attest - a lot of people did. In these meetings there was an indirect, and underlying set of questions on his side:</p>\n<blockquote>\n  <p class=\"paragraph\" >Where is the front end chapter now?\n  Where does it need to be?\n  What do we need to do to get where it needs to be?</p>\n</blockquote>\n<p class=\"paragraph\" >I found that the first question was an easy one to answer as I lived through it daily, but couldn't answer the second and third questions with nearly as much clarity. And there was frustration, notably, from both parts; my boss couldn't see where the front end needed to be, nor did I have the certainty to tell him with confidence what we needed to do to get there. I used to truly believe and tell him that if we wanted to drive forward as a chapter, then we would need to hire someone very senior that could teach us.</p>\n<p class=\"paragraph\" >Whilst all this was happening, I decided that I wanted to pursue new opportunities in another country, and so handed my notice in at Attest - a company for which I cannot recommend enough to work at. My notice period, three months, gave me a lot of time to think about what it is I liked about myself at Attest, and what it was that didn't like. Who was it that I wanted to be at my next work place? It dawned on me that the person I wanted to be was someone who would be able to easily answer those two questions that I couldn't: Where does the front end chapter need to get to, and how do we get there?</p>\n<p class=\"paragraph\" >I've always thought of myself as a good engineer, have read the \"bibles\" of software engineering, and keep up to date with latest tech. But I wanted to level up, and I did some things which I had rarely done in the past; I bought a number of books on micro frontend architecture, cross-functional squads and scaling front end teams (technical books are something I had previously underestimated, and used more as reference points) and I started listening to podcasts, and really explored the depths and crevices of a lot of major frameworks' codebases. I'm not saying I had never read books, or listened to podcasts, or explored codebases before, but now I explicitly dedicated time to improve myself in areas I knew I hadn't explored to their fullest.</p>\n<p class=\"paragraph\" >In my mind I started to build a much clearer mental model as to how a front end system can scale, and found more confidence in my opinions. Most importantly, I felt as though those two questions which I looked at with such hesitation were now not as scary. I'm not saying I understand exactly how to answer them in any way or form, but I feel like I started to <a href=\"https://www.forbes.com/sites/brucekasanoff/2018/03/21/you-dont-know-what-you-dont-know/?sh=22cfe82f573d\">know what I didn't know</a>.</p>\n<p class=\"paragraph\" >I started at Attest when it was a small company of nine, and it's now grown to house over one hundred and thirty employees, with a global client base. We've been through a lot, and I like to think I've been an important asset at times. We started out as two front end engineers, and are now a team of twelve, which comes with difficult decisions, both technically and culturally. But over the past few months, where I've started to dedicate focused time to work on myself and limitations in my own knowledge, I have realised one major perspective that I hadn't before: that the path we've come from to where we are now is far shorter than the path between where we are now, to where we need to get to.</p>\n<p class=\"paragraph\" >Now, where I wanted to get to with this post. I would rarely take my 10% time, and when I did it would be to fix a part of the product that had bugged me for a while. I would improve aspects of our&nbsp;<a href=\"https://developer.mozilla.org/en-US/docs/Learn/Performance/perceived_performance\">perceived performance</a>&nbsp;and I introduced fragments of&nbsp;<a href=\"https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces\">optimistic UI</a>, as well as a few other things I'm proud of. </p>\n<p class=\"paragraph\" >But in these two months leading up to my leaving date, I feel much more confident in answering those two questions that have been at the back of my mind. I now have a more comprehensive understanding of how a chapter can evolve, I have a better grasp of what the unknowns might be, and I have gained a much clearer view of what it is that I don't know.</p>\n<p class=\"paragraph\" >It's very easy to get absorbed in the products you are working on, it's only natural as you work on them all day, every day. So when given time to \"improve the product\", one's natural instinct can very often be inclined to automating something that directly affects their work, or improving that part of the product they didn't like. However something I wish I had learned a lot sooner was that a lot of the time by introspecting and understanding your own knowledge gaps and trying to learn how to better yourself in those areas, you will inevitably become a stronger asset to the company you work for. So my suggestion is that if you work at a company as awesome as Attest, which offers 10% time, introduce concepts you feel are missing from the product, but also look outside of the company-spectrum for while, and use that 10% to focus on bettering yourself. It will make you a better, or more knowledgeable person, which in turn will make the company a better one too.</p>","id":202102131048,"metaData":{"tags":["permanent-note"]},"linksTo":[202102241726],"label":"The Value of 10% Time"},{"bodyHtml":"<p class=\"paragraph\" >I recently started a new way of memorizing the things I learn, which is essentially to write them in my own words as soon as I read them.</p>\n<p class=\"paragraph\" >I follow the <a href=\"https://en.wikipedia.org/wiki/Zettelkasten\">Zettelkasten</a> method of taking notes. Take a peek at the notes I've kept and how they connect to each other.</p>\n<p class=\"paragraph\" >My hope is that one day, eventually my zettelkasten will be big enough that it can be of use to other people. This is <strong>still very bare</strong>, I plan on adding to it as I read (and note down) more.</p>\n<h3 id=\"howtouseit\">How to use it</h3>\n<p class=\"paragraph\" >Easy. Click on the nodes on the right hand side. Colours represent their \"tags\", and the links recommend the next node. I plan on adding better visualisation in the future so hang on tight.</p>\n<h3 id=\"shoutout\">Shout out</h3>\n<p class=\"paragraph\" >All reference you see right now are from Michael Geers' <a href=\"https://www.manning.com/books/micro-frontends-in-action\">Micro Frontends in Action</a>, so thank you for being my first reference guide.</p>","id":202102241726,"metaData":{"tags":["index-card"]},"linksTo":[202101301828],"label":"Notes Archive"}],"edges":[{"source":202101301828,"target":202101301829},{"source":202101301828,"target":202102071208},{"source":202101301829,"target":202101301828},{"source":202102042224,"target":202102071141},{"source":202102042224,"target":202102042246},{"source":202102042232,"target":202102061841},{"source":202102042232,"target":202102071605},{"source":202102042246,"target":202102042224},{"source":202102061841,"target":202102062302},{"source":202102062241,"target":202102071208},{"source":202102062241,"target":202102071240},{"source":202102062302,"target":202102071240},{"source":202102071117,"target":202102042224},{"source":202102071117,"target":202102042232},{"source":202102071141,"target":202102042224},{"source":202102071208,"target":202102062241},{"source":202102071208,"target":202102062241},{"source":202102071208,"target":202102071240},{"source":202102071208,"target":202102062241},{"source":202102071208,"target":202102071605},{"source":202102071208,"target":202102071117},{"source":202102071240,"target":202102062241},{"source":202102071240,"target":202102062302},{"source":202102071605,"target":202102042224},{"source":202102071605,"target":202102042232},{"source":202102072253,"target":202101301828},{"source":202102072253,"target":202102121403},{"source":202102121749,"target":202102241726},{"source":202102131048,"target":202102241726},{"source":202102241726,"target":202101301828}]}})</script></main></body></html>