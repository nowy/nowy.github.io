<h1>Micro Frontends Asset Loading</h1><p>Loading asset bundles from multiple micro frontends can be a challenging task. Ensuring different micro frontends can deploy independently, deprecated cached assets are cache busted on user's machines, and asset synchronization during deployments are all accounted for, micro frontends need to version manifests alongside their code.</p><h3>Considerations</h3><p>Two main considerations need to accounted for when loading assets; cache-busting to ensure the user always sees the latest version, and synchronization to assert that rolled deployments do not cause 404 errors.</p><h4>Cache-busting and independent deployments</h4><p>Most browsers (and applications) are optimised to cache static assets (images, CSS files, JavaScript, etc.) on a user's machine. This is a verified way to increase performance, however causes difficulties providing files when continuous deployment is a business requirement. For example exposing a file called <code>fragment.css</code> will no longer suffice as it will be cached on a user's machine, and updates to <code>fragment.css</code> will not reflect on that user's machine. In order to assert that a file gets cached, a technique called &quot;cache busting&quot; is used where a fingerprint is added to the end of the URL (E.g. <code>fragment.72.js</code>). Each subsequent deployment will add a new fingerprint.</p><h4>Synchronization</h4><p>In order to deal with high amounts of traffic, applications usually run multiple instances, and a load balancer is then used to distribute requests evenly across these instances. As new versions of an application are deployed, their instances are replaced with new instances, one-by-one to assert most instances are running at once.</p><p>The downside to replacing instances one-by-one is that whilst deploying new versions, the resources provided by each instance could differ. For example if a deployment is undergoing and one instance has been replaced, but the rest haven't, then one instance might serve <code>fragment.74.js</code>, whilst the others can serve <code>fragment.73.js</code>. A user could make a request to an application which has a dependency on <code>fragment.74.js</code> but when it makes the request to fetch this resource, the load balancer could redirect it to an instance only containing <code>fragment.73.js</code>, causing a 404 on this resource.</p><h3>Solving for caching and synchronization</h3><p>In order to guarantee the user's resources are cache busted, and synchronization is accounted when deploying, each micro frontend can provide a <code>manifest.json</code>. This manifest should contain links to the static resources, as well as the version it is providing.</p><pre><code>{
  version: 1,
  css: 'my-css.123.css',
  js: 'my-js.123.js',
}
</code></pre><p>When the HTML content is fetched, a <code>version</code> is returned in the header, when we look at our cached <code>manifest.json</code>, we compare its version to the one returned in the HTML response. If they don't match then we request a new <code>manifest.json</code> and update it.</p><blockquote><p>#fe-library <a href="https://podium-lib.io/">Podium</a> provides out-of-the-box functionality for creating versioned manifests.</p></blockquote><h2>Links</h2><h2>References</h2>